---
layout:     post
title:      "webpack打包源代码配置"
subtitle:   ""
date:       2023-10-30
author:     " Shallow Dreamer "
header-img: "img/post-bg-js-version.jpg"
tags:
    - webpack
---

如果你发现通过 Webpack 打包的 JavaScript 代码中仍然可以查到源代码的痕迹，可能是因为在Webpack的配置中没有进行足够的代码混淆和压缩，或者开启了SourceMap。以下是一些步骤来确保你的代码不容易被反向工程：

1. **关闭SourceMap**：在Webpack的配置文件中，确保关闭SourceMap生成。SourceMap是一种用于开发时的工具，它帮助开发者在浏览器中调试源代码，但在生产环境中应该关闭，因为它可以泄露源代码信息。

   在Webpack配置中，可以这样设置：
   ```javascript
   // webpack.config.js
   module.exports = {
     // ...
     devtool: 'none', // 或者 'source-map'，或者 'eval'，视情况而定
     // ...
   };
   ```

   设置为 `'none'` 或者不设置 `devtool` 选项会关闭SourceMap。

2. **代码压缩**：使用Webpack的`terser-webpack-plugin`等插件来进行代码压缩和混淆。这将减小代码的大小并增加反向工程的难度。

   在Webpack配置中，可以添加以下插件来进行代码压缩和混淆：

   ```javascript
   const TerserPlugin = require('terser-webpack-plugin');

   module.exports = {
     // ...
     optimization: {
       minimize: true,
       minimizer: [new TerserPlugin()],
     },
     // ...
   };
   ```

3. **代码分离**：将应用程序拆分为多个模块，以便只有必要的代码被加载。这可以通过Webpack的代码分割功能来实现。这减小了源代码泄露的风险，因为只有当前页面所需的代码会被加载。

4. **环境变量**：在Webpack中，可以使用环境变量来区分开发环境和生产环境。确保在生产环境下不输出敏感信息。

5. **加密和认证**：如果你的前端应用需要与后端进行通信，使用HTTPS来加密通信，以防止中间人攻击。确保后端使用适当的认证机制来验证请求，只允许经过身份验证的用户访问敏感数据。

请注意，虽然这些步骤可以增加代码的安全性，但不可能完全防止源代码的泄露。任何在浏览器上执行的代码都可以被理论上反向工程出来，但这些措施可以增加攻击者获取源代码的难度。

如果在Webpack打包后的`app.js`中仍然可以看到源代码的导入语句，这可能是因为Webpack默认的配置中包含了注释，导致导入语句保留在输出的代码中。要确保导入语句被彻底删除，你可以采取以下步骤：

1. **开启 Tree Shaking**：Tree Shaking 是一个用于消除未使用代码的技术，它可以确保只有实际使用的模块被打包到最终的输出中。确保你的模块遵循 ES6 模块语法，以便Webpack可以进行 Tree Shaking。

2. **使用 Production 模式**：在生产环境中，Webpack会自动进行一些优化，包括删除注释。确保你在生产环境下运行Webpack。可以在命令行中使用 `-p` 或 `--mode production` 标志，或者在Webpack配置中设置`mode`选项为`'production'`。

   ```javascript
   // webpack.config.js
   module.exports = {
     mode: 'production',
     // ...其他配置...
   };
   ```

3. **使用 UglifyJS 或 Terser 插件**：这些插件可以进一步压缩和混淆你的代码，以减小文件大小并删除未使用的导入语句。

   ```javascript
   const TerserPlugin = require('terser-webpack-plugin');

   module.exports = {
     // ...其他配置...
     optimization: {
       minimize: true,
       minimizer: [new TerserPlugin()],
     },
   };
   ```

4. **检查其他插件和配置**：确保你没有添加其他插件或配置选项，它们可能导致导入语句被保留在输出的代码中。

5. **手动移除注释**：如果以上步骤不起作用，你还可以使用 Webpack 插件来手动移除注释。一个常见的插件是 `remove-comments-webpack-plugin`。

   安装插件：

   ```
   npm install remove-comments-webpack-plugin --save-dev
   ```

   在Webpack配置中使用：

   ```javascript
   const RemoveCommentsPlugin = require('remove-comments-webpack-plugin');
   
   module.exports = {
     // ...其他配置...
     plugins: [
       new RemoveCommentsPlugin(),
       // ...其他插件...
     ],
   };
   ```

注意，虽然这些步骤可以减小输出文件的大小和删除未使用的代码，但无法完全防止源代码的泄露。反编译总是可能的，但这些步骤可以增加攻击者获取源代码的难度。



```js
// 初始化第一个图表
var chart1 = echarts.init(document.getElementById('chart1'));
var option1 = {
    // 第一个图表的配置
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross'
        },
        formatter: function (params) {
            // 格式化 Tooltip 显示的内容
            var data = params[0].data;
            return 'Chart 1: ' + data.value;
        }
    },
    // 其他配置项...
};
chart1.setOption(option1);

// 初始化第二个图表
var chart2 = echarts.init(document.getElementById('chart2'));
var option2 = {
    // 第二个图表的配置
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross'
        },
        formatter: function (params) {
            // 格式化 Tooltip 显示的内容
            var data = params[0].data;
            return 'Chart 2: ' + data.value;
        }
    },
    // 其他配置项...
};
chart2.setOption(option2);

// 监听第一个图表的鼠标悬停事件
chart1.on('mousemove', function (params) {
    // 获取第一个图表当前鼠标所在的数据点
    var data1 = params.seriesData;

    // 更新第二个图表的 Tooltip
    chart2.dispatchAction({
        type: 'showTip',
        seriesIndex: 0,
        dataIndex: params.dataIndex
    });
});

// 监听第二个图表的鼠标悬停事件
chart2.on('mousemove', function (params) {
    // 获取第二个图表当前鼠标所在的数据点
    var data2 = params.seriesData;

    // 更新第一个图表的 Tooltip
    chart1.dispatchAction({
        type: 'showTip',
        seriesIndex: 0,
        dataIndex: params.dataIndex
    });
});

```

```js
tooltip: {
  trigger: 'axis',
  position: function (point, params, dom, rect, size) {
    // 自定义 Tooltip 的位置
    var top = point[1] - size.contentSize[1] - 10; // 向上偏移 10px
    var left = point[0] - size.contentSize[0] / 2; // 水平居中

    // 限制 Tooltip 的范围
    var containerWidth = document.getElementById('chartContainer').offsetWidth;
    var containerHeight = document.getElementById('chartContainer').offsetHeight;

    if (left < 0) {
      left = 0;
    } else if (left + size.contentSize[0] > containerWidth) {
      left = containerWidth - size.contentSize[0];
    }

    if (top < 0) {
      top = 0;
    } else if (top + size.contentSize[1] > containerHeight) {
      top = containerHeight - size.contentSize[1];
    }

    return [left, top];
  }
}

```

```js
tooltip: {
  trigger: 'axis',
  position: function (point, params, dom, rect, size) {
    // 自定义 Tooltip 的位置
    var top = point[1] - size.contentSize[1] - 10; // 向上偏移 10px
    var left = point[0] - size.contentSize[0] / 2; // 水平居中
    return [left, top];
  }
}

```

```js
option = {
  tooltip: {
    trigger: 'axis',
    formatter: function (params) {
      var tooltipContent = '';
      params.forEach(function (item) {
        var dataIndex = item.dataIndex; // 数据索引
        var seriesIndex = item.seriesIndex; // 系列索引
        var value = item.value; // 数据值
        var yAxisIndex = option.series[seriesIndex].data[dataIndex][2] || 0; // Y 轴索引
        // 根据 Y 轴索引添加不同的后缀
        var suffix = ''; // 后缀
        if (yAxisIndex === 0) {
          suffix = '单位1'; // 第一个 Y 轴的后缀
        } else if (yAxisIndex === 1) {
          suffix = '单位2'; // 第二个 Y 轴的后缀
        }
        // 拼接 Tooltip 内容，添加后缀
        tooltipContent += item.marker + ' ' + item.seriesName + ': ' + value + suffix + '<br>';
      });
      return tooltipContent;
    }
  },
  xAxis: {
    type: 'value' // X 轴是数值型的
  },
  yAxis: [
    {
      type: 'value'
    },
    {
      type: 'value'
    }
  ],
  series: [
    {
      name: '系列1',
      type: 'line',
      // series.data 中包含 X 轴和 Y 轴的数据以及 Y 轴索引
      data: [
        [1, 10, 0], // 第一个数据项，X 轴为 1，Y 轴为 10，Y 轴索引为 0
        [2, 20, 0], // 第二个数据项，X 轴为 2，Y 轴为 20，Y 轴索引为 0
        [3, 30, 1], // 第三个数据项，X 轴为 3，Y 轴为 30，Y 轴索引为 1
        [4, 40, 1], // 第四个数据项，X 轴为 4，Y 轴为 40，Y 轴索引为 1
        [5, 50, 0],  // 第五个数据项，X 轴为 5，Y 轴为 50，Y 轴索引为 0
        // 更多数据项...
      ],
      yAxisIndex: 0
    },
    {
      name: '系列2',
      type: 'line',
      // series.data 中包含 X 轴和 Y 轴的数据以及 Y 轴索引
      data: [
        [1, 20, 0], // 第一个数据项，X 轴为 1，Y 轴为 20，Y 轴索引为 0
        [2, 30, 1], // 第二个数据项，X 轴为 2，Y 轴为 30，Y 轴索引为 1
        [3, 40, 0], // 第三个数据项，X 轴为 3，Y 轴为 40，Y 轴索引为 0
        [4, 50, 1], // 第四个数据项，X 轴为 4，Y 轴为 50，Y 轴索引为 1
        [5, 60, 0],  // 第五个数据项，X 轴为 5，Y 轴为 60，Y 轴索引为 0
        // 更多数据项...
      ],
      yAxisIndex: 1
    }
    // 更多系列...
  ]
};

```

如果你需要在请求图片时携带认证 token，并且又要利用浏览器缓存，可以结合前面的方法，在自定义组件中使用浏览器缓存，并在请求图片时添加认证 token。以下是更新后的代码：

### 步骤 1: 更新自定义组件以利用浏览器缓存和携带 token

```vue
<template>
  <el-image :src="imageUrl" />
</template>

<script>
import { ref } from 'vue';
import axios from 'axios';

export default {
  name: 'ImageWithCacheAndAuth',
  props: {
    src: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const imageUrl = ref('');

    const loadImage = async () => {
      try {
        const response = await axios.get(props.src, {
          responseType: 'blob',
          headers: {
            Authorization: `Bearer ${yourToken}`
          }
        });
        const blobUrl = URL.createObjectURL(response.data);
        imageUrl.value = blobUrl;
      } catch (error) {
        console.error('Failed to load image', error);
      }
    };

    // 在组件挂载时，加载图片
    loadImage();

    return {
      imageUrl
    };
  }
};
</script>
```

### 步骤 2: 使用自定义组件

```vue
<template>
  <div>
    <image-with-cache-and-auth src="https://your-image-url.com/image.jpg" />
  </div>
</template>

<script>
import ImageWithCacheAndAuth from './components/ImageWithCacheAndAuth.vue';

export default {
  components: {
    ImageWithCacheAndAuth
  }
};
</script>
```

这样做的好处是，浏览器可以根据图片 URL 进行缓存，而在每次请求图片时，都会携带认证 token。即使图片 URL 不变，但如果图片内容发生变化，服务器依然可以根据 token 返回新的图片内容。

如果你有多个父组件都包含了保活的子组件，并且这些父组件都传递了相同的图片 URL 给子组件，那么在这种情况下，由于浏览器缓存的存在，图片可能会在多个父组件中共享，从而导致图片展示的问题。

因为浏览器会根据图片 URL 进行缓存，而不是根据页面的组件结构。所以，如果你在多个父组件中使用了相同的图片 URL，那么这些组件在展示图片时都会使用同一个缓存的图片数据。这可能会导致以下问题：

1. **图片显示不一致：** 如果一个父组件更新了图片，那么其他父组件中的相同图片也会更新，因为它们共享同一个缓存。
2. **性能问题：** 如果多个父组件都有大量的保活子组件，并且这些子组件都加载了大量的图片，那么可能会导致浏览器的缓存空间被占满，进而影响页面的性能。

为了解决这个问题，你可以考虑以下方案：

1. **使用不同的图片 URL：** 如果可能的话，尽量确保每个父组件都使用不同的图片 URL，这样可以避免图片共享的问题。
2. **动态生成图片 URL：** 如果图片 URL 是根据某些条件动态生成的，可以尝试根据不同的条件生成不同的 URL，以确保每个父组件使用不同的图片 URL。
3. **禁用浏览器缓存：** 如果你不希望浏览器缓存影响图片展示，可以考虑在图片 URL 中添加随机参数或者禁用浏览器缓存头，这样可以确保每次请求都会获取最新的图片数据。
