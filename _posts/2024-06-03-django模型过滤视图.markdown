---
layout:     post
title:      "django模型过滤视图"
subtitle:   ""
date:       2024-06-03
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - django
---

当然，以下是每一行代码的详细解释，帮助你理解如何实现多表联合查询并进行过滤。

### 1. 定义模型

在 `your_app/models.py` 中定义 `Author` 和 `Book` 模型：

```python
# your_app/models.py

from django.db import models

# 定义Author模型
class Author(models.Model):
    # 定义作者姓名字段，最大长度为100
    name = models.CharField(max_length=100)
    # 定义作者出生日期字段
    birth_date = models.DateField()

    # 定义字符串表示形式，返回作者姓名
    def __str__(self):
        return self.name

# 定义Book模型
class Book(models.Model):
    # 定义书名字段，最大长度为200
    title = models.CharField(max_length=200)
    # 定义外键字段，关联到Author模型，删除Author时删除关联的Book
    author = models.ForeignKey(Author, related_name='books', on_delete=models.CASCADE)
    # 定义书籍出版日期字段
    published_date = models.DateField()

    # 定义字符串表示形式，返回书名
    def __str__(self):
        return self.title
```

### 2. 创建序列化器

在 `your_app/serializers.py` 中创建两个模型的序列化器：

```python
# your_app/serializers.py

from rest_framework import serializers
from .models import Author, Book

# 定义Author模型的序列化器
class AuthorSerializer(serializers.ModelSerializer):
    class Meta:
        # 指定序列化器对应的模型是Author
        model = Author
        # 指定需要序列化的字段
        fields = ['id', 'name', 'birth_date']

# 定义Book模型的序列化器
class BookSerializer(serializers.ModelSerializer):
    # 嵌套Author序列化器，用于序列化Author字段
    author = AuthorSerializer()

    class Meta:
        # 指定序列化器对应的模型是Book
        model = Book
        # 指定需要序列化的字段
        fields = ['id', 'title', 'author', 'published_date']
```

### 3. 创建过滤类

在 `your_app/filters.py` 中创建过滤类：

```python
# your_app/filters.py

import django_filters
from .models import Book

# 定义Book模型的过滤类
class BookFilter(django_filters.FilterSet):
    # 定义过滤器，按书名模糊查询
    title = django_filters.CharFilter(lookup_expr='icontains')
    # 定义过滤器，按作者姓名模糊查询
    author_name = django_filters.CharFilter(field_name='author__name', lookup_expr='icontains')
    # 定义过滤器，按出版日期精确查询
    published_date = django_filters.DateFilter()

    class Meta:
        # 指定过滤器对应的模型是Book
        model = Book
        # 指定可以被过滤的字段
        fields = ['title', 'author_name', 'published_date']
```

### 4. 创建视图

在 `your_app/views.py` 中创建视图，并添加过滤功能：

```python
# your_app/views.py

from rest_framework import viewsets
from django_filters.rest_framework import DjangoFilterBackend
from .models import Book
from .serializers import BookSerializer
from .filters import BookFilter

# 定义Book模型的视图集
class BookViewSet(viewsets.ModelViewSet):
    # 指定视图集使用的查询集
    queryset = Book.objects.all()
    # 指定视图集使用的序列化器
    serializer_class = BookSerializer
    # 指定视图集使用的过滤后端
    filter_backends = [DjangoFilterBackend]
    # 指定视图集使用的过滤类
    filterset_class = BookFilter
```

### 5. 配置 URL

在 `your_app/urls.py` 中配置路由：

```python
# your_app/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import BookViewSet

# 创建一个默认的路由对象
router = DefaultRouter()
# 注册Book视图集，路由前缀为'books'
router.register(r'books', BookViewSet, basename='book')

# 定义URL模式
urlpatterns = [
    # 包含路由对象生成的所有URL模式
    path('', include(router.urls)),
]
```

在项目的 `urls.py` 中包含应用的 URL：

```python
# your_project/urls.py

from django.contrib import admin
from django.urls import path, include

# 定义项目级别的URL模式
urlpatterns = [
    # 管理后台的URL模式
    path('admin/', admin.site.urls),
    # 包含应用的URL模式，前缀为'api/'
    path('api/', include('your_app.urls')),
]
```

### 6. 运行项目

启动开发服务器：

```bash
python manage.py runserver
```

### 总结

访问 `http://127.0.0.1:8000/api/books/`，并使用以下参数进行过滤，例如：

- `http://127.0.0.1:8000/api/books/?title=some_title`：按书名模糊查询
- `http://127.0.0.1:8000/api/books/?author_name=some_author`：按作者姓名模糊查询
- `http://127.0.0.1:8000/api/books/?published_date=2023-01-01`：按出版日期精确查询

### 示例

假设数据库中有以下数据：

- Author: J.K. Rowling, Birth Date: 1965-07-31
- Book: Harry Potter and the Philosopher's Stone, Author: J.K. Rowling, Published Date: 1997-06-26

你可以通过访问 `http://127.0.0.1:8000/api/books/?author_name=rowling` 来获取作者名中包含 "rowling" 的所有书籍。返回的结果将包含 "Harry Potter and the Philosopher's Stone" 这本书。

通过这个示例，你可以了解如何在视图中实现多表联合查询并进行过滤。希望这对你有所帮助！如果你有任何问题或需要进一步的解释，请随时告诉我。

------

当然，下面是每行代码的详细解释。

### 1. 定义模型

在 `your_app/models.py` 中定义 `Book` 模型：

```python
# your_app/models.py

from django.db import models

# 定义 Book 模型
class Book(models.Model):
    # 定义书名字段，最大长度为200
    title = models.CharField(max_length=200)
    # 定义作者字段，最大长度为100
    author = models.CharField(max_length=100)
    # 定义出版日期字段
    published_date = models.DateField()

    # 定义字符串表示形式，返回书名
    def __str__(self):
        return self.title
```

### 2. 创建过滤类

在 `your_app/filters.py` 中创建过滤类：

```python
# your_app/filters.py

import django_filters
from django_filters import rest_framework as filters
from .models import Book

# 定义一个用于处理字符类型列表的自定义过滤器
class CharInFilter(filters.BaseInFilter, filters.CharFilter):
    pass

# 定义 Book 模型的过滤器类
class BookFilter(filters.FilterSet):
    # 使用自定义过滤器来处理书名的列表过滤
    title = CharInFilter(field_name='title', lookup_expr='in')
    # 使用自定义过滤器来处理作者的列表过滤
    author = CharInFilter(field_name='author', lookup_expr='in')
    # 使用标准日期过滤器来处理出版日期的精确过滤
    published_date = filters.DateFilter()

    class Meta:
        # 指定过滤器对应的模型是 Book
        model = Book
        # 指定可以被过滤的字段
        fields = ['title', 'author', 'published_date']
```

### 3. 创建视图以处理 XLSX 文件

在 `your_app/views.py` 中创建一个视图来处理 XLSX 文件，并检查数据库中是否存在这些数据：

```python
# your_app/views.py

import pandas as pd
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django_filters.rest_framework import DjangoFilterBackend
from .models import Book
from .filters import BookFilter

# 定义一个处理 XLSX 文件上传的视图
class UploadXLSXView(APIView):
    # 指定使用 DjangoFilterBackend 作为过滤后端
    filter_backends = [DjangoFilterBackend]
    # 指定使用的过滤器类
    filterset_class = BookFilter

    # 处理 POST 请求的方法
    def post(self, request, *args, **kwargs):
        # 从请求中获取上传的文件
        file = request.FILES.get('file')
        if not file:
            # 如果没有提供文件，返回400错误响应
            return Response({"error": "No file provided"}, status=status.HTTP_400_BAD_REQUEST)

        # 使用 Pandas 读取 XLSX 文件
        df = pd.read_excel(file)

        # 期望的列名
        expected_columns = ['title', 'author', 'published_date']
        # 检查文件中是否包含所有期望的列
        if not all(column in df.columns for column in expected_columns):
            # 如果缺少任何期望的列，返回400错误响应
            return Response({"error": "Invalid file format"}, status=status.HTTP_400_BAD_REQUEST)

        # 获取所有标题、作者和出版日期，转换为列表
        titles = df['title'].tolist()
        authors = df['author'].tolist()
        published_dates = df['published_date'].tolist()

        # 创建过滤器集实例，用于过滤数据库中的数据
        filterset = BookFilter(data={
            'title': titles,
            'author': authors,
            'published_date': published_dates
        }, queryset=Book.objects.all())

        results = []
        if filterset.is_valid():
            # 如果过滤器集有效，逐行检查数据是否存在于数据库中
            for title, author, published_date in zip(titles, authors, published_dates):
                # 使用过滤器集查询数据库
                exists = filterset.qs.filter(title=title, author=author, published_date=published_date).exists()
                # 将结果添加到结果列表中
                results.append({
                    "title": title,
                    "author": author,
                    "published_date": published_date,
                    "exists": exists
                })
        else:
            # 如果过滤器集无效，返回400错误响应
            return Response(filterset.errors, status=status.HTTP_400_BAD_REQUEST)

        # 返回结果列表作为响应
        return Response(results, status=status.HTTP_200_OK)
```

### 4. 配置 URL

在 `your_app/urls.py` 中添加新视图的路由：

```python
# your_app/urls.py

from django.urls import path
from .views import UploadXLSXView

# 定义应用的URL模式
urlpatterns = [
    # 配置处理 XLSX 文件上传的视图
    path('upload/', UploadXLSXView.as_view(), name='upload-xlsx'),
]
```

### 5. 更新项目的 URL 配置

在项目的 `urls.py` 中包含应用的 URL：

```python
# your_project/urls.py

from django.contrib import admin
from django.urls import path, include

# 定义项目级别的URL模式
urlpatterns = [
    # 管理后台的URL模式
    path('admin/', admin.site.urls),
    # 包含应用的URL模式，前缀为'api/'
    path('api/', include('your_app.urls')),
]
```

### 6. 启动项目

启动开发服务器：

```bash
python manage.py runserver
```

### 使用说明

向 `http://127.0.0.1:8000/api/upload/` 发起 POST 请求，上传包含 `title`、`author` 和 `published_date` 列的 XLSX 文件。视图将检查这些数据是否在数据库中存在，并返回检查结果。

### 示例 XLSX 文件格式

| title        | author        | published_date |
| ------------ | ------------- | -------------- |
| Book Title 1 | Author Name 1 | 2023-01-01     |
| Book Title 2 | Author Name 2 | 2023-01-02     |
| Book Title 3 | Author Name 3 | 2023-01-03     |

### 代码详细解释

1. **模型定义**：
    - `Book` 模型定义了书籍的基本信息：书名、作者和出版日期。

2. **过滤类**：
    - `CharInFilter` 是一个自定义过滤器，用于处理字符类型的列表。
    - `BookFilter` 定义了过滤 `Book` 模型的字段：书名、作者和出版日期。

3. **视图定义**：
    - `UploadXLSXView` 是一个 API 视图，用于处理 XLSX 文件上传。
    - `post` 方法处理上传的文件，读取 XLSX 文件内容，验证列名，并使用过滤器集检查数据是否存在于数据库中。
    - `filterset` 用于创建一个过滤器集实例，使用上传的数据进行查询。

4. **URL 配置**：
    - `your_app/urls.py` 配置了 `UploadXLSXView` 视图的路由。
    - `your_project/urls.py` 包含应用的 URL 配置，确保路由正确。

通过这个示例，你可以了解如何使用 `BaseInFilter` 和 `django-filter` 来处理从 XLSX 文件中获取的数据，并检查这些数据是否存在于数据库中。如果你有任何问题或需要进一步的解释，请随时告诉我。

------

为了实现从 `BookColumn` 表中获取校验规则并应用于前端传递的数据或 XLSX 文件中的数据，首先我们需要在 `BookColumn` 表中存储这些校验规则。然后，我们需要在视图中读取这些规则，并在处理数据时应用这些规则进行校验。下面是一个完整的示例代码，包括定义模型、视图和校验逻辑。

### 1. 定义模型

首先，定义 `Book` 和 `BookColumn` 模型：

```python
# your_app/models.py

from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    published_date = models.DateField()

    def __str__(self):
        return self.title

class BookColumn(models.Model):
    FIELD_TYPE_CHOICES = (
        ('char', 'CharField'),
        ('date', 'DateField'),
    )

    name = models.CharField(max_length=100)  # 字段名
    field_type = models.CharField(max_length=10, choices=FIELD_TYPE_CHOICES)  # 字段类型
    regex = models.CharField(max_length=200, blank=True, null=True)  # 正则表达式校验
    required = models.BooleanField(default=True)  # 是否必填

    def __str__(self):
        return self.name
```

### 2. 创建过滤类

如果需要的话，可以继续使用过滤类。这里我们不改变之前的过滤逻辑。

```python
# your_app/filters.py

import django_filters
from django_filters import rest_framework as filters
from .models import Book

class CharInFilter(filters.BaseInFilter, filters.CharFilter):
    pass

class BookFilter(filters.FilterSet):
    title = CharInFilter(field_name='title', lookup_expr='in')
    author = CharInFilter(field_name='author', lookup_expr='in')
    published_date = filters.DateFilter()

    class Meta:
        model = Book
        fields = ['title', 'author', 'published_date']
```

### 3. 创建视图以处理校验

在 `your_app/views.py` 中创建一个视图来处理数据校验：

```python
# your_app/views.py

import pandas as pd
import re
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Book, BookColumn

class UploadXLSXView(APIView):

    def post(self, request, *args, **kwargs):
        file = request.FILES.get('file')
        if not file:
            return Response({"error": "No file provided"}, status=status.HTTP_400_BAD_REQUEST)

        # 读取 XLSX 文件
        df = pd.read_excel(file)

        # 获取所有的校验规则
        validation_rules = BookColumn.objects.all()
        errors = []

        for index, row in df.iterrows():
            row_errors = {}
            for rule in validation_rules:
                field_name = rule.name
                field_value = row.get(field_name)

                # 校验必填项
                if rule.required and (field_value is None or pd.isna(field_value)):
                    row_errors[field_name] = 'This field is required.'
                    continue

                # 正则表达式校验
                if rule.regex and field_value:
                    if not re.match(rule.regex, str(field_value)):
                        row_errors[field_name] = 'Invalid format.'

            if row_errors:
                errors.append({"row": index + 1, "errors": row_errors})

        if errors:
            return Response({"errors": errors}, status=status.HTTP_400_BAD_REQUEST)

        # 如果没有错误，处理并保存数据
        results = []
        for index, row in df.iterrows():
            book_data = {
                'title': row['title'],
                'author': row['author'],
                'published_date': row['published_date']
            }
            # 在数据库中创建或更新 Book 实例
            book, created = Book.objects.update_or_create(
                title=book_data['title'],
                defaults=book_data
            )
            results.append(book_data)

        return Response(results, status=status.HTTP_200_OK)
```

### 4. 配置 URL

在 `your_app/urls.py` 中添加新视图的路由：

```python
# your_app/urls.py

from django.urls import path
from .views import UploadXLSXView

urlpatterns = [
    path('upload/', UploadXLSXView.as_view(), name='upload-xlsx'),
]
```

### 5. 更新项目的 URL 配置

在项目的 `urls.py` 中包含应用的 URL：

```python
# your_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('your_app.urls')),
]
```

### 6. 启动项目

启动开发服务器：

```bash
python manage.py runserver
```

### 使用说明

向 `http://127.0.0.1:8000/api/upload/` 发起 POST 请求，上传包含 `title`、`author` 和 `published_date` 列的 XLSX 文件。视图将根据 `BookColumn` 表中的校验规则检查这些数据，如果有错误将返回错误信息。

### 示例 XLSX 文件格式

| title        | author        | published_date |
| ------------ | ------------- | -------------- |
| Book Title 1 | Author Name 1 | 2023-01-01     |
| Book Title 2 | Author Name 2 | 2023-01-02     |
| Book Title 3 | Author Name 3 | 2023-01-03     |

### 代码详细解释

1. **模型定义**：
    - `Book` 模型定义了书籍的基本信息：书名、作者和出版日期。
    - `BookColumn` 模型定义了字段的校验规则，包括字段名、字段类型、正则表达式和是否必填。

2. **视图定义**：
    - `UploadXLSXView` 是一个 API 视图，用于处理 XLSX 文件上传。
    - `post` 方法处理上传的文件，读取 XLSX 文件内容，获取校验规则，并应用这些规则对数据进行校验。
    - `validation_rules` 获取所有的校验规则。
    - 对每一行数据，根据校验规则检查字段值是否符合要求，如果有错误，记录错误信息。
    - 如果有错误，返回400错误响应。
    - 如果没有错误，处理并保存数据。

通过这个示例，你可以了解如何使用从 `BookColumn` 表中获取的校验规则，对前端传递的数据或 XLSX 文件中的数据进行校验。如果你有任何问题或需要进一步的解释，请随时告诉我。

------

为了实现这个功能，我们需要以下步骤：

1. **创建 `BookColumn` 模型** 用于存储字段的校验信息。
2. **创建一个函数**，从 `BookColumn` 表中获取校验信息，并对传递的数据或从 XLSX 文件中读取的数据进行校验。
3. **在视图中使用这个校验函数**，对数据进行校验并返回错误信息。

### 1. 创建 `BookColumn` 模型

在 `your_app/models.py` 中定义 `BookColumn` 模型：

```python
from django.db import models

# 定义 Book 模型
class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    published_date = models.DateField()

    def __str__(self):
        return self.title

# 定义 BookColumn 模型
class BookColumn(models.Model):
    field_name = models.CharField(max_length=100)  # Book 模型中的字段名
    validation_type = models.CharField(max_length=50)  # 校验类型（如 regex, max_length, min_value）
    validation_value = models.CharField(max_length=200)  # 校验值（如正则表达式）

    def __str__(self):
        return f'{self.field_name} - {self.validation_type}'
```

### 2. 创建数据校验函数

在 `your_app/validators.py` 中创建校验函数：

```python
import re
from django.core.exceptions import ValidationError
from .models import BookColumn

def validate_data(data):
    errors = []
    columns = BookColumn.objects.all()
    
    for column in columns:
        field_name = column.field_name
        validation_type = column.validation_type
        validation_value = column.validation_value

        value = data.get(field_name)
        
        if validation_type == 'regex':
            if not re.match(validation_value, str(value)):
                errors.append(f'{field_name} does not match the required pattern.')
        
        elif validation_type == 'max_length':
            if len(str(value)) > int(validation_value):
                errors.append(f'{field_name} exceeds maximum length of {validation_value}.')
        
        elif validation_type == 'min_length':
            if len(str(value)) < int(validation_value):
                errors.append(f'{field_name} is less than minimum length of {validation_value}.')
        
        elif validation_type == 'max_value':
            if float(value) > float(validation_value):
                errors.append(f'{field_name} exceeds maximum value of {validation_value}.')
        
        elif validation_type == 'min_value':
            if float(value) < float(validation_value):
                errors.append(f'{field_name} is less than minimum value of {validation_value}.')

    return errors
```

### 3. 在视图中使用校验函数

修改 `your_app/views.py`，在处理数据时进行校验：

```python
import pandas as pd
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django_filters.rest_framework import DjangoFilterBackend
from .models import Book
from .filters import BookFilter
from .validators import validate_data

class UploadXLSXView(APIView):
    filter_backends = [DjangoFilterBackend]
    filterset_class = BookFilter

    def post(self, request, *args, **kwargs):
        file = request.FILES.get('file')
        if not file:
            return Response({"error": "No file provided"}, status=status.HTTP_400_BAD_REQUEST)

        df = pd.read_excel(file)
        expected_columns = ['title', 'author', 'published_date']
        if not all(column in df.columns for column in expected_columns):
            return Response({"error": "Invalid file format"}, status=status.HTTP_400_BAD_REQUEST)

        titles = df['title'].tolist()
        authors = df['author'].tolist()
        published_dates = df['published_date'].tolist()

        results = []
        for index, row in df.iterrows():
            row_data = row.to_dict()
            errors = validate_data(row_data)
            if errors:
                results.append({
                    "row": index + 1,
                    "errors": errors
                })
                continue
            
            filterset = BookFilter(data=row_data, queryset=Book.objects.all())
            if filterset.is_valid():
                exists = filterset.qs.filter(title=row_data['title'], author=row_data['author'], published_date=row_data['published_date']).exists()
                results.append({
                    "title": row_data['title'],
                    "author": row_data['author'],
                    "published_date": row_data['published_date'],
                    "exists": exists
                })
            else:
                results.append({
                    "row": index + 1,
                    "errors": filterset.errors
                })

        return Response(results, status=status.HTTP_200_OK)
```

### 4. 配置 URL

在 `your_app/urls.py` 中添加新视图的路由：

```python
from django.urls import path
from .views import UploadXLSXView

urlpatterns = [
    path('upload/', UploadXLSXView.as_view(), name='upload-xlsx'),
]
```

### 5. 更新项目的 URL 配置

在项目的 `urls.py` 中包含应用的 URL：

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('your_app.urls')),
]
```

### 6. 启动项目

启动开发服务器：

```bash
python manage.py runserver
```

### 使用说明

向 `http://127.0.0.1:8000/api/upload/` 发起 POST 请求，上传包含 `title`、`author` 和 `published_date` 列的 XLSX 文件。视图将校验这些数据是否符合 `BookColumn` 表中的校验规则，并返回错误信息。

### 示例 XLSX 文件格式

| title        | author        | published_date |
| ------------ | ------------- | -------------- |
| Book Title 1 | Author Name 1 | 2023-01-01     |
| Book Title 2 | Author Name 2 | 2023-01-02     |
| Book Title 3 | Author Name 3 | 2023-01-03     |

### 示例 `BookColumn` 数据

| field_name     | validation_type | validation_value    |
| -------------- | --------------- | ------------------- |
| title          | max_length      | 200                 |
| author         | max_length      | 100                 |
| published_date | regex           | ^\d{4}-\d{2}-\d{2}$ |

通过这个示例，你可以了解如何从 XLSX 文件中获取数据，并使用存储在 `BookColumn` 表中的校验规则对这些数据进行校验。如果你有任何问题或需要进一步的解释，请随时告诉我。
